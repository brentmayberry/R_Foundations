install.packages("dplyr")
library("dplyr")
library("tidyr")

## What is clean data in R? ##

## GROUND RULES FOR HOW R WORKS WITH DATASETS BEST ##
## 1) Each variable in the data set is placed in its own column
## 2) Each observation is placed in its own row
## 3) Each value is placed in its own cell*



######### TIDYR ###########
## This package helps you get your data to R specs
## gather() and spread()
## both rely on key value pairs

messy = data.frame(
  name = c("Wilbur", "Petunia", "Gregory"),
  a = c(67, 80, 64),
  b = c(56, 90, 50)
)

## what's wrong with this data?
## first identify the variables: name, drug, heart rate
## Do they follow the rules of tidyr?
messy %>% gather(drug, heartrate, a:b)



## http://www.listendata.com/2016/08/dplyr-tutorial.html

## dplyr is similar to sql statements (select, group by, joins)

## look at sample data set, income generated by states from 2002 to 2015
mydata = read.csv("sampledata.csv")
View(mydata)

######### SAMPLE FUNCTION ###########

## select random rows by defining the number of rows you want
s1 = sample_n(mydata, 5)
## re-run this and you will get a different random 5 every time


## select random rows by defining a percentage
## this will be more helpful when using predictive algorithms
s2 = sample_frac(mydata, 0.2)

######### DISTINCT FUNCTION ###########

## eliminate duplicates based on all variable values
dis1 = distinct(mydata)

## eliminate duplicates based on a specified variable value
dis2 = distinct(mydata, Index, .keep_all=TRUE)
dis3 = distinct(mydata, Index, Y2010, .keep_all=TRUE)

######### SELECT FUNCTION ###########
## pre-req: data must be in data frame format because it uses columns as params

## from the df, get index and state through y2008
mydata2 = select(mydata, Index, State:Y2008)

## from the df, drop variables
mydata3 = select(mydata, -Index, -State)

## select variables based on partial description
mydata4 = select(mydata, starts_with("Y"))
## drop
mydata5 = select(mydata, -starts_with("Y"))

## rearrange the data, put state as the first column
mydata6 = select(mydata, State, everything())


######### RENAME FUNCTION ###########
## must be a data frame
## provide new name first, then old name that it is replacing
renamed_data = rename(mydata, Index1=Index)


######### FILTER FUNCTION ###########

## single criteria
filtered_data = filter(mydata, Index=="A")

## multiple criteria
multi_select_data1 = filter(mydata, Index %in% c("A", "C"))
multi_select_data2 = filter(mydata, Index %in% c("A", "C") & Y2002 >= 1300000)
multi_select_data3 = filter(mydata, Index %in% c("A", "C") | Y2002 >= 1300000)

## not operator
not_op_filtered_data = filter(mydata, !Index =="A")


######### ARRANGE FUNCTION ###########
## arrange is used to carry out sorting operations
desc_mydata = arrange(mydata, desc(Index))
asce_mydata = arrange(mydata, Index, desc(Y2002))


######### PIPE FUNCTION ###########
## allows you to pipe functions together by sending results to the next parameter

dt1 = mydata %>% select(Index, State) %>% sample_n(10)

## is the same as...

dt2 = sample_n(select(mydata, Index, State),10)


t = mydata %>% filter(Index %in% c("A", "C","I")) %>% group_by(Index) %>% do(head( . , 2))


######### MUTATE FUNCTION ###########
## talk about feature engineering

## adding a new var named change
mydata_addvar = mutate(mydata, change=Y2015/Y2014)

## mutate all variables
mydata_allmutate = mutate_all(mydata, funs("new"=.*1000))


######### OTHER THINGS DPLYR CAN DO ###########
## join()
## intersect()
## union()



















